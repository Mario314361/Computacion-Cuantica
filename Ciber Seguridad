# Importar librerÃ­as necesarias
import cirq
import numpy as np
import matplotlib.pyplot as plt
import multiprocessing
import base64


# Definir qubits
q0 = cirq.GridQubit(0, 0)
q1 = cirq.GridQubit(1, 0)


# Crear circuito cuÃ¡ntico
def crear_circuito():
Â  Â  circuito = cirq.Circuit(
Â  Â  Â  Â  cirq.H(q0), Â # Aplicar Hadamard al primer qubit
Â  Â  Â  Â  cirq.CNOT(q0, q1), Â # Aplicar CNOT para entrelazar
Â  Â  Â  Â  cirq.measure(q0, key='q0'), Â # Medir el primer qubit
Â  Â  Â  Â  cirq.measure(q1, key='q1') Â  # Medir el segundo qubit
Â  Â  )
Â  Â  return circuito


# FunciÃ³n para ejecutar la simulaciÃ³n
def simular_circuito(repeticiones, use_parallel=False):
Â  Â  circuito = crear_circuito()
Â  Â  simulator = cirq.Simulator()


Â  Â  # Ejecutar en paralelo si se activa la opciÃ³n
Â  Â  if use_parallel:
Â  Â  Â  Â  with multiprocessing.Pool() as pool:
Â  Â  Â  Â  Â  Â  resultados = pool.map(lambda _: simulator.run(circuito), range(repeticiones))
Â  Â  else:
Â  Â  Â  Â  resultados = [simulator.run(circuito) for _ in range(repeticiones)]


Â  Â  # Extraer las mediciones
Â  Â  mediciones = [r.data['q0'][0] * 2 + r.data['q1'][0] for r in resultados]
Â  Â  return mediciones


# FunciÃ³n para generar la clave
def generar_clave(mediciones, cantidad_numeros):
Â  Â  clave_binaria = ''.join(format(med, '02b') for med in mediciones)
Â  Â  longitud_clave = cantidad_numeros * 8 Â # 1 nÃºmero decimal = 8 bits
Â  Â  clave_final_binaria = clave_binaria[:longitud_clave]
Â  Â 
Â  Â  # Convertir a decimal
Â  Â  bloques = [clave_final_binaria[i:i+8] for i in range(0, len(clave_final_binaria), 8)]
Â  Â  clave_decimal = [int(bloque, 2) for bloque in bloques]
Â  Â 
Â  Â  # Convertir a hexadecimal
Â  Â  clave_hexadecimal = ''.join(format(num, '02X') for num in clave_decimal)
Â  Â 
Â  Â  # Convertir a Base64
Â  Â  clave_bytes = bytes(clave_decimal)
Â  Â  clave_base64 = base64.b64encode(clave_bytes).decode()


Â  Â  return clave_final_binaria, clave_decimal, clave_hexadecimal, clave_base64


# FunciÃ³n para graficar la distribuciÃ³n de bits
def graficar_distribucion(mediciones):
Â  Â  etiquetas = ["00", "01", "10", "11"]
Â  Â  frecuencias = [mediciones.count(i) for i in range(4)]
Â  Â  total = sum(frecuencias)
Â  Â 
Â  Â  plt.figure(figsize=(6, 4))
Â  Â  bars = plt.bar(etiquetas, frecuencias, color=['blue', 'red', 'green', 'purple'], alpha=0.7, edgecolor='black')
Â  Â 
Â  Â  # Agregar valores en las barras
Â  Â  for bar, freq in zip(bars, frecuencias):
Â  Â  Â  Â  plt.text(bar.get_x() + bar.get_width()/2, bar.get_height(), f"{(freq/total)*100:.2f}%", ha='center', va='bottom')
Â  Â 
Â  Â  plt.xlabel("Bits generados")
Â  Â  plt.ylabel("Frecuencia")
Â  Â  plt.title("DistribuciÃ³n de bits generados en la clave")
Â  Â  plt.show()


# FunciÃ³n principal
def main():
Â  Â  print("\nğŸ’¡ Bienvenido al Generador de Claves CuÃ¡nticas ğŸ’¡")
Â  Â 
Â  Â  # Pedir cantidad de nÃºmeros en la clave
Â  Â  while True:
Â  Â  Â  Â  try:
Â  Â  Â  Â  Â  Â  cantidad_numeros = int(input("\nğŸ”¢ Â¿CuÃ¡ntos nÃºmeros deseas en la clave? "))
Â  Â  Â  Â  Â  Â  if cantidad_numeros > 0:
Â  Â  Â  Â  Â  Â  Â  Â  break
Â  Â  Â  Â  Â  Â  else:
Â  Â  Â  Â  Â  Â  Â  Â  print("âš ï¸ Ingresa un nÃºmero mayor a 0.")
Â  Â  Â  Â  except ValueError:
Â  Â  Â  Â  Â  Â  print("âŒ Entrada no vÃ¡lida. Ingresa un nÃºmero entero.")


Â  Â  # Pedir si desea usar procesamiento en paralelo
Â  Â  use_parallel = input("\nğŸš€ Â¿Deseas acelerar la simulaciÃ³n con mÃºltiples nÃºcleos? (s/n): ").strip().lower() == 's'


Â  Â  # Ejecutar simulaciÃ³n
Â  Â  repeticiones = cantidad_numeros * 4 Â # Asegura suficientes bits
Â  Â  print("\nâ³ Generando clave cuÃ¡ntica...")
Â  Â  mediciones = simular_circuito(repeticiones, use_parallel)
Â  Â 
Â  Â  # Generar clave
Â  Â  clave_binaria, clave_decimal, clave_hexadecimal, clave_base64 = generar_clave(mediciones, cantidad_numeros)


Â  Â  # Mostrar resultados
Â  Â  print("\nğŸ”‘ Clave generada en diferentes formatos:")
Â  Â  print(f"ğŸŸ¢ Binario: {clave_binaria}")
Â  Â  print(f"ğŸ”µ Decimal: {clave_decimal}")
Â  Â  print(f"ğŸŸ  Hexadecimal: {clave_hexadecimal}")
Â  Â  print(f"ğŸŸ£ Base64: {clave_base64}")


Â  Â  # Mostrar grÃ¡fica de distribuciÃ³n
Â  Â  graficar_distribucion(mediciones)


# Ejecutar programa
if __name__ == "__main__":
Â  Â  main()
